package main

import (
	"image/color"
	"os"
	"fmt"
	"image"
	"golang.org/x/image/bmp"
	_ "golang.org/x/image/bmp"
	"time"
	"os/exec"
	"bytes"
)

var (
	// Token for " "
	tokenSpace = color.RGBA{0,0,0,255}
	// Token for "\t"
	tokenIndent = color.RGBA{255,0,0,255}


	// Token for ":"
	tokenColon = color.RGBA{24, 24, 24, 255}
	// Token for "("
	tokenBracketL = color.RGBA{0, 0, 126, 255}
	// Token for ")"
	tokenBracketR = color.RGBA{0, 0, 162, 255}
	// Token for "["
	tokenSqBracketL = color.RGBA{126, 0, 0, 255}
	// Token for "]"
	tokenSqBracketR = color.RGBA{162, 0,0 , 255}
	// Token for quotes.
	tokenQuote = color.RGBA{ 0, 27, 0, 255}
	// Token for singlequotes.
	tokenSingleQuote = color.RGBA{ 0, 28, 0, 255}

	// Token for prematurely ending a statement, aka ";"
	tokenStatementEnd = color.RGBA{12, 12, 12, 255}

	// Token for "*"
	tokenStar = color.RGBA{8, 8, 8, 255}
	// Token for "!"
	tokenNot = color.RGBA{16, 16, 16, 255}
	// Token for "<"
	tokenLess = color.RGBA{32, 32, 32, 255}
	// Token for ">"
	tokenMore = color.RGBA{64, 64, 64, 255}
	// Token for "="
	tokenEq = color.RGBA{128, 128, 128, 255}

	// Token for "&"
	tokenAnd = color.RGBA{148, 148, 148, 255}
	// Token for "|"
	tokenOr = color.RGBA{200, 200, 200, 255}

	// Token for "+"
	tokenAdd = color.RGBA{220, 220, 220, 255}
	// Token for "-"
	tokenSub = color.RGBA{240, 240, 240, 255}

	// Token for "."
	tokenDot = color.RGBA{255, 255, 255, 255}


	// Token for "package"
	tokenPackage = color.RGBA{16, 16, 0, 255}
	// Token for "import"
	tokenImport = color.RGBA{32, 32, 0, 255}
	// Token for "func"
	tokenFunc = color.RGBA{64, 64, 0, 255}
	// Token for "var"
	tokenVar = color.RGBA{128, 128, 0, 255}
	// Token for "type"
	tokenType = color.RGBA{255, 255, 0, 255}


	// Token for "struct"
	tokenStruct = color.RGBA{255, 255, 4, 255}
	// Token for "interface"
	tokenInterface = color.RGBA{255, 255, 8, 255}
	// Token for "int"
	tokenInt = color.RGBA{255, 255, 16, 255}
	// Token for "string"
	tokenString = color.RGBA{255, 255, 32, 255}
	// Token for "float"
	tokenFloat = color.RGBA{255, 255, 64, 255}
	// Token for "rune"
	tokenRune = color.RGBA{255, 255, 128, 255}

	// Token specifying an ASCII character (for function names and such) is encoded in the green channel.
	tokenNaming = color.RGBA{1, 0, 0, 255}


	// Token for "if"
	tokenIf = color.RGBA{16, 0, 0, 255}
	// Token for "else"
	tokenElse = color.RGBA{32, 0, 0, 255}
	// Token for "for"
	tokenFor = color.RGBA{64, 0, 0, 255}
	// Token for "for"
	tokenSwitch = color.RGBA{128, 0, 0, 255}

	// Token generated by a prepass.
	tokenInternalSkip = color.RGBA{0,0,0,0}


)

func main() {
	//To avoid compilation issues
	_ = tokenNaming
	{
		file := "CODE.bmp"
		f, err := os.OpenFile(file, os.O_RDONLY, 0644)
		if err != nil {
			LogError(err)
			return
		}
		defer f.Close()

		fimg, err := bmp.Decode(f)
		if err != nil {
			fmt.Println(err)
			return
		}

		// Preprocesses code to make sure that no bracket hell breaks loose.
		fmt.Println("Preprocessing ", f, "...")
		fimg = PreProcessCode(fimg)

		fgo, err := os.OpenFile("CODE.go", os.O_CREATE|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			LogError(err)
			return
		}
		defer fgo.Close()
		fmt.Println("Transpiling ", f, "...")
		fgo.WriteString(ConvertToGo(fimg, false))
		fmt.Println("Formatting ", f, "...")
		exec.Command("go", "fmt", "CODE.go").Run()
	}

	fmt.Println("Compilation successful!\n ---- Execution ---- ")
	cmd := exec.Command("go", "run", "CODE.go")
	var out bytes.Buffer
	cmd.Stdin = os.Stdin
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		LogError(err)
		return
	}
	cmd.Wait()
	fmt.Println(out.String())
}


func PreProcessCode(img image.Image) image.Image {
	out := image.NewRGBA(img.Bounds())
	for x := 0; x < img.Bounds().Max.X; x++ {
		for y := 0; y < img.Bounds().Max.Y; y++ {
			out.Set(x, y, img.At(x,y))
		}
	}
	for y := 0; y < img.Bounds().Max.Y; y++ {
		fb := img.Bounds().Max.X
		for x := img.Bounds().Max.X; x > 0; x-- {
			if img.At(x,y) != tokenSpace {
				break
			}
			fb++
		}
		out.Set(fb, y, tokenInternalSkip)
	}
	return out
}

func LogWarning(errOnWarn bool, input ...interface{}) {
	if errOnWarn {
		LogError(input)
		return
	}
	fmt.Println("[", time.Now().UTC(), " WARNING] ", input)
}

func LogError(input ...interface{}) {
	fmt.Println("[", time.Now().UTC(), " ERROR] ", input)
	os.Exit(1)
}

func ConvertToGo(img image.Image, errOnWarn bool) string {
	out := ""
	iIndex := 0
	iIndexTab := ""
	for y := 0; y < img.Bounds().Max.Y; y++ {
		for x := 0; x < img.Bounds().Max.X; x++ {
			pixl := img.At(x, y)
			//fmt.Println(x,y, pixl)

			if pixl == tokenInternalSkip {
				break
			}
			if pixl == tokenPackage {
				out += "package "
			}
			if pixl == tokenImport {
				out += "import "
			}
			if pixl == tokenFunc {
				out += "func "
			}
			if pixl == tokenVar {
				out += "var "
			}
			if pixl == tokenType {
				out += "type "
			}

			if pixl == tokenFor {
				out += "for "
			}
			if pixl == tokenIf {
				out += "if "
			}
			if pixl == tokenElse {
				out += "else "
			}
			if pixl == tokenSwitch {
				out += "switch "
			}

			if pixl == tokenEq {
				out += "="
			}
			if pixl == tokenAnd {
				out += "&"
			}
			if pixl == tokenOr {
				out += "|"
			}


			if pixl == tokenDot {
				out += "."
			}
			if pixl == tokenQuote {
				out += "\""
			}
			if pixl == tokenSingleQuote {
				out += "'"
			}
			if pixl == tokenSpace {
				out += " "
			}
			if pixl == tokenColon {
				out += ":"
			}
			if pixl == tokenStatementEnd {
				out += ";"
			}
			if pixl == tokenStar {
				out += "*"
			}
			if pixl == tokenNot {
				out += "!"
			}
			if pixl == tokenLess {
				out += "<"
			}
			if pixl == tokenMore {
				out += ">"
			}
			if pixl == tokenSub {
				out += "-"
			}
			if pixl == tokenAdd {
				out += "+"
			}

			if pixl == tokenBracketL {
				out += "("
			}
			if pixl == tokenBracketR {
				out += ")"
			}
			if pixl == tokenSqBracketL {
				out += "["
			}
			if pixl == tokenSqBracketR {
				out += "]"
			}

			if pixl == tokenInterface {
				out += "interface"
			}
			if pixl == tokenStruct {
				out += "struct"
			}
			if pixl == tokenInt {
				out += "int"
			}
			if pixl == tokenString {
				out += "string"
			}
			if pixl == tokenRune {
				out += "rune"
			}
			if pixl == tokenFloat {
				out += "float"
			}

			if pixl == tokenIndent {
				if x > iIndex {
					iIndex++
					out += "{ "
					iIndexTab = ""
					for i := 0; i < iIndex; i++ {
						iIndexTab += "\t"
					}
				} else if x == iIndex - 1 {
					iIndex--
					if out[len(out)-1] == '\t' {
						out = out[:len(out)-1]
					}
					out += "} "
					iIndexTab = ""
					for i := 0; i < iIndex; i++ {
						iIndexTab += "\t"
					}
				} else {
					LogWarning(errOnWarn,"Invalid/redundant placement of \"\t\" at line ", y, " column ", x)
				}
			}

			if r, g, _ ,_ := pixl.RGBA(); uint8(r / 0x101) == 1 {
				out += string(rune(uint8(g / 0x101)))
			}
		}
		out += "\n" + iIndexTab
	}

	return out //"package main; import \"fmt\"; func main() { fmt.Println(\"transpiler failed spectacularly\"); }"
}